import UIKit

//数据都是以二进制的形式存储的，位运算是专门针对二进制数据的一种运算方式。在创建数值变量时可以通过道加 “0b”qi的级的方式将数值设置为二进制



//十进制数8 UTnt8类型，其为8位的无符号整型，也就是说，任何一个Uint8类型的变量都是采用8个二进制位来存储数据的。因此，可以理解为a变量实际存储的数据为00001000。位运算的实质是对数据的每一个二进制位进行逻辑运算
var a:UInt8 = 0b1000 //创建一个UInt8类型的变量，将十进制数8以二进制的方式赋值


//按位取反运算符 ～ 的作用是将数据的每一位都进行取反操作，即如果当前位为0，则运算后变为1，如果当前位为1，则运算后变为0。对上面创建的变量a进行按位取反运算后，其存储的数据将变为11110111，即十进制数247。
//运算后 a的值变为十进制数247 a存储的二进制数为11110111
a = ~a

//按位与运算符 “&”需要有两个操作数，其作用是将两个操作数相同的位进行逻辑与运算。即如果两个对应位的值都为1，则运算后此位结果为1。如果其中有一个位的值为0，则运算后此位结果为0。
//使用二进制数11110000与a进行按位与运算，结果为11110000 即十进制数240
a = 0b11110000&a


// 按位或运算符 ｜ 需要有两个操作数，其作用是将两个操作数相同的位进行逻辑或运算。即如果两个对应位的值有一个为1，则运算后此位结果为1；如果两个对应位的值都为0，则运算后此位结果为0
//使用二进制数11111111与a进行按位或运算，结果为11111111 即十进制数255
a = 0b11111111|a

//按位 异或 运算符^需要有两个操作数，将两个操作数相同的位进行逻辑异或运算。即如果两个对应位的值相同，则运算后此位的值为0；如果两个对应位的值不同，则运算后结果为1
//使用二进制数11110000与a进行按位异或运算 结果为00001111 即十进制数15
a = 0b11110000^a

//按位左移运算符“＜<”用于将数据每一位上的值进行左移操作，示例如下：
//将a按位左移1位，结果为00011110 即十进制数30。 最后一位加0，去掉第一位。向左移动后面加0
a = a<<1

//按位右移运算符 << 用于将数据每一位上的值进行右移操作
//将a按位右移1位，结果为00001111 即十进制数15。第一位加0，去掉最后一位。 向右移动前面加0
a = a>>1

//进行按位左移或者右移运算的时候，有可能出现丢失数据位的情况，例如对于 Uint8 类型将二进制数据 00001111 向左移动6位，结果为11000000，将二进制数据 11110000 向右移动6位，结果为 00000011。
a<<6

/*
 谓溢出，是指超出数据所属类型的最大值/最小值
 
 位运算符的主要功能是对二进制数据进行位运算等操作。正常的运算是不允许出现子
溢出出行为的，开发者使用溢出运算符可以控制是否允许溢出运算。 */


/* 值溢出
 数值可以出现向上溢出或向下溢出
 
 溢出也会发生在有符号整型数值上
 
 对于无符号与有符号整型数值来说，当出现上溢出时，它们会从数值所能容纳的最大数变成最小的数。同样的，当发生下溢出时，它们会从所容纳的最小数变成最大的数。
 

 
 */

var num1:UInt8 = 251//UInt8 最大值为二进制11111111，即为十进制255。  uint8整型数范围 0 ~ 255
var num2 = num1 &+ 20 // 251+ 5 为0 。可以看到，在代码中，使用了 &+ 运算符，在没有发生溢出时结果是与常规的算术运算符是相同的，而当溢出时也会返回正常的数值，而不是报错。
print(num2) //15

num1 = 0
num2 = num1 &- 1 //当发生下溢出时，它们会从所容纳的最小数变成最大的数。
print(num2) //255

var num3:Int8 = -128 //int8整型数范围 -128 ~ 127
var num4 = num3 &- 1 //溢出。
print(num4)//127



var b:UInt8 = 255
//进行支持溢出的加操作.它们会从数值所能容纳的最大数变成最小的数
b = b &+ 1 //0

//进行支持溢出的减操作 当发生下溢出时，它们会从所容纳的最小数变成最大的数。
b = b &- 1 //255

//进行支持溢出的乘操作
b = b &* 2 //254
//对二进制数据进行乘 2运算，实质上就是对二进制数据进行左移一位的运算，例如二进制数据 11111111*2=11111110


//=====================函数重载=====================//
//重载运算符和自定义运算符都是开发者自定义运算符功能的手段，差别在于：重载运算符是给系统已经存在的运算符追加新的功能，而自定义运算符是完全定义一个系统不存在的运算符，以实现特定的运算功能。

// 重载的概念最初针对函数，对同一个函数名设置不同的参数类型以实现不同的功能被称为函数的重载。

func addFuncInt(param1:Int,param2:Int)->Int{
    return param1+param2
}

addFuncInt(param1: 3, param2: 4)


//上面的示例代码用来进行整型数据的加法是完全可以的，但是进行浮点型数据的加法就会出现问题，如果直接将浮点数传入addFunc()函数中，编译器就会报类型错误，这时你可能想要创建一个针对浮点数的加法运算，示例如下：
func addFuncDouble(param1:Double,param2:Double)->Double{
    return param1+param2
}
addFuncDouble(param1: 0.5, param2: 0.3)
//这样解决了问题，但是这种设计思路十分糟糕，实现相同功能的函数，由于参数的不同，被生生切成了两个，其实可以使用相同的函数名addFunc()通过重载实现不同类型参数的计算


//创建整型的加法函数
func addFunc(param1:Int,param2:Int) -> Int {
    return param1+param2
}
//重载addFunc实现浮点型数据的加法
func addFunc(param1:Double,param2:Double) -> Double {
    return param1+param2
}
//再次重载addFunc，实现字符串类型的加法
func addFunc(param1:String,param2:String)->String{
    return param1+param2
}
//以上代码通过重载的方式对不同数据类型实现了加法操作，并且在调用加法函数的时候，只需要记住这一个函数名即可，这就大大增强了代码的统一性。

//=================================================//

//运算符的重载是指在系统已经存在的运算符上扩展新的功能。其实在前面章节中使用的加号运算符“+”就是通过重載实现的，可以直接使用“＋”进行整型数据、浮点型数据甚至字符串类型数据的相加操作。下面我们自定义一个圆形的类，通过重载加号运算符 + 来实现对对圆形类实例的相加操作。

//设计圆形类如下，其中有两个属性，分别表示圆形半径与圆心
class Circle{
    //圆心
    var center:(Double,Double)
    //半径
    var radius:Double
    init(center:(Double,Double),radius:Double){
        self.center = center
        self.radius = radius
    }
}

//定义两个Circle实例进行相加操作时应执行这样的运算：两个Circle实例相加返回一个新的Circle实例，并且这个新的Circle实例的圆心为第一个Circle操作数的圆心，新的Circle实例的半径为两个操作数Circle实例半径的和，重载加法运算符如下：

func +(param1:Circle,param2:Circle) -> Circle {
    return Circle(center: param1.center, radius: param1.radius+param2.radius)
}
//可以发现，重载运算符的语法格式与函数十分相似。实际上，运算符就是通过函数的方式定义的


//在某些场景下，运算符的确可以像函数一样来使用，例如在一个函数参数中传入闭包时，可以直接传入某个功能类型的运算符，示例如下：
func myFunc(closure:(Circle,Circle)->Circle) {
    
}
//将重載的加法运算符传入
myFunc(closure: +)

//swift中有覆写的概念，覆写是指子类对父类中的属性和方法进行适合自身的重新实现

//-----------自定义运算符---------//


////自定义前缀运算符++
//prefix operator ++
////进行自定义运算符实现
//prefix func ++(param:Int)->Int{
//    return param+1
//}
////将返回6
//++5


/*自定义运算符分为两个步骤，首先开发者需要对要定义的运算行进行声明，如 prefix operator ++。在声明运算符的结构中，prefix是声明运算符的类型。、
 
 可以使用perfix关键字将其声明为前缀运算符，使用infix关键字将其声明为中缀运算符，postfix声明为后缀运算符

 进行运算符的实现时，后缀和前缀运算符只能有一个参数，参数在func关键字前需要表明要实现的运算符类型，中缀运算行需要有两个参数且func关键字前不需要额外标明

*/



//自定义中缀运算符
//infix operator ++
//func ++(param1:Int,parma2:Int)->Int{
//    return param1*param1+parma2*parma2
//}
////将返回41
//5++4


////自定义后缀运算符
//postfix operator ++
//postfix func ++(param1:Int) -> Int {
//    return param1+param1
//}
////将返回10
//5++

/*前缀运算符是指只有一个操作数且在使用运算符进行运算时，运算符需要出现在操作数的前面
 
 中缀运算符需要有两个操作数，且在进行运算时运算符需要出现在两个操作数的中间
 
 后缀运算符只能有一个操作数，在运算时后缀运算符需要出现在操作数的后面
 
 需要注意，swift语言中提供了许多Unicode字符，可用于运算符的自定义，但是也有一些规则，自定义运算符常使用如下字符作为开头：/ = + ！ * % < > & | ^ ? ~
 
 也可以使用点 . 来进行运算符的定义,需要注意， 如果.出现在自定义运算符的开头，则运算符中可以出现多个. 例如 .+. 如果不在开头，那么自定义运算符只允许出现一次
 
 swift语言中也有一些保留符号，它们不可以单独被重秋和自定义，保留符号有： = -> // /* */ . < > & ? !
 
 */


//----------运算符的优先级与结合性 precedence and associativity-------------- //

//优先级决定 计算顺序
//结合性  决定运算符是从左向右运算 还是 从右向左运算

/*    ！ 逻辑非运算符      +取正运算        ～按位取反运算           -取负运算
 
..<右开区间运算      ...闭区间运算      is类型检查运算     as, as?, as! 类型转换运算
 
 ？？空合并运算          ～=模式匹配运算
 
？：   条件运算             以下均为右结合性
=      赋值
 *= 复合乘法赋值运算
 /= 复合除法赋值运算
 %= 复合取余赋值运算
 += 复合加法赋值运算
 -= 复合减法赋值运算
 <<= 复合按位左移赋值运算
 >>= 复合按位右移赋值运算
 &= 复合按位与运算赋值运算
 ｜= 复合按位或运算赋值运算
 ^= 复合按位异或运算赋值运算
 &&= 复合逻辑与运算赋值运算
 ||= 复合逻辑或运算赋值运算
 
 其实更多情况下，会直接使用小括号来决定表达式的执行顺序
*/

/*
 运算结果23 
 过程如下：
 2*10 = 20
 20*3 = 60
 60/4 = 15
 8+15 = 23
 */
8+2*10*3/4




//在重载运算符操作中，并不会改变原运算符的结合性和优先级，但对于自定义运算符，可以设置其结合性与优先级，示例如下：

precedencegroup customGroup {
    higherThan:AdditionPrecedence       // 优先级比加法运算符的优先级高
    lowerThan:MultiplicationPrecedence  // 优先级比乘法运算符的优先级低
    assignment:true         // 设置执行可选链操作时的优先级
    associativity:none      // 定义结合性
}
// 定义中缀运算符，其属性由customGroup描述
infix operator +++:customGroup

//如以上代码所示，其中 precedencegroup 关键字用来定义运算符的优先级组。在自定义优先级时，我们可以为其设置一个优先级组，系统默认内置了非常多的优先级组，如加法运算符优先级组、乘法运算符优先级组、位运算符优先级组等，我们可以直接使用，例如：

// 定义中缀运算符，其优先级属性由与系统的加法相关运算符一致
infix operator ++++:AdditionPrecedence

/*
 当系统内置的优先级组不能满足我们的要求时，即可使用precedencegroup 关键字来自定义优先级组，其中 higerThan 用来定义当前优先级组的优先级比哪个优先级组高，lowerThan用来定义当前
 优先级组的优先级比哪个优先级组低，assignment用来设罝是否会影响可选链赋值运算中的优先级判定规则，associativity用来设置可以选择left或者right来定义成左结合性或者右结合性，设置为none
 则为默认结合性。
 
 */



//1.模拟C语言通过自定义运算符的方式实现前缀自增、前缀自减、后缀自增、后缀自减运算符。
//定义前缀自增运算符
prefix operator ++
//定义后缀自增运算符
postfix operator ++
//定义前缀自减运算符
prefix operator --
//定义后缀自减运算符
postfix operator --
//进行实现
prefix func ++( param:inout Int)->Int{
    param+=1
    return param
}
postfix func ++( param:inout Int)->Int{
    param+=1
    return param-1
}
prefix func --( param:inout Int)->Int{
    param-=1
    return param
}
postfix func --( param:inout Int)->Int{
    param-=1
    return param+1
}

//2.Swift语言中的加法运算符不能支持对区间范围的相加操作，重载加法运算符，使其支持区间的追加，例如(0…5)+5计算后的结果为区间0…10。
func +(param:ClosedRange<Int>,param2:Int)->ClosedRange<Int>{
    return param.lowerBound...param.upperBound+param2
    
}
//将得到 0...10
var newRange = 0...5+5

//3.自定义新后缀运算符“!*”，其功能是对某个数进行阶乘计算。
postfix operator *!
postfix func *! (param:Int)->Int{
    var result = 1
    var tmp = param
    while tmp>0 {
        result *= tmp
        tmp-=1
    }
    return result
}
//得到计算结果120
5*!




