#IB
interface Builder（IB）是用于设计和测试图形用户界面Graphical User Interface（GUI）的应用程序

IB 的工具箱是可扩展的，都可以开发新的对象，并将其加入IB 的工具箱中

UI控件存储在XIB或NIB文件中，其实XIB文件是一个XML格式的文件，可以通过编辑工具打开兵改写这个文件。当编译程序时，这些视图控件被编译成一个NIB文件

View Controller Scene 面板：
First Responder（第一响应者）：表示用户正在与之交互的对象。当用户使用ios应用程序时，可能有多个对象响应用户的手势或单击。第一响应者是当前与用户交互的对象。例如，当用户在文本框中输入时，该文本框将是第一响应者，直到用户移到其他文本框或控件。

View Controller（视图控制器）：表示加载应用程序中的故事板场景并与之交互的对象。场景描述的其他所有对象几乎都是由它实例化的

view视图：
一个 UIView 实例，表示将被视图控制器加载并显示在 iOS 设备屏幕中的布局。从本质上说，视图是一种层次结构，这意味着当我们在界面中添加控件时它们将包含在视图中。我们甚至可在视图中添加其他视图，以便将控件编组或创建可作为一个整体显示或隐藏的界面元素。

First Responder（第一响应者）与 View Controller（视图控制器）标用于表示应用程序中的非界面对象，我们使用的所有故事板场景都包含它们。

使用独特的视图控制器名称/标签有利于场景命名。IB自动将场景名设置为视图控制器的名称或标签（如果设置了标签），并加上后缀。例如，如果给视图控制器设置了标签 Recipe Listing，场景名将变成 Recipe Listing Scene。本项目包含一个名为 View Controller的通用类，此类负责与场景交互。

UIView 是一个矩形区域，可以包含内容以及响应用户事件（触摸等）。加入视图中的所有控件（按钮、文本框等）都是UIView 的子类。
将按钮和其他界面元素称为子视图，而将包含它们的视图称为父视图

##使用IB布局工具
参考线
选择菜单栏中的 Editor- Add Horizontal Guide命令或 Editor-- Add Vertical Guide 命令，可以手工添加参考线


对齐
Editor->Align命令中选择合适的对齐方式

在 Show 下拉列表中，可以选择 Frame Rectangle 或 Layout Rectangle
当选择 Frame Rectangle 时，将准确指出对象在屏幕上占据的区域
当选择 Layout Rectangle时，将考虑对象周围的间距。

当在 IB 中选择一个对象后，如果按住 Option 键并移动光标，会显示选定对象与当前光标指向的对象之间的距离

在ios应用中可以使用专业屏幕阅读器技术 VoiceOver，此技术集成了语音合成功能，可以帮助开发人员导航应用程序。在使用 VoiceOver 后，当触摸界面元素时会看到有关其用途和用法的简短描述。
 Identity Inspector  ->    Accessibility（辅助功能）
即使使用文本标签这样的对象，也应配置其 Traits 属性，以指出它们是静态文本，这可以让用户知道不能与之交互.

选中 Label， 然后按 OptiontCommandt 4 快捷键,打开 Attributes Inspector 面板

#使用 xcode 编写 MVC 应用程序

当我们开始编程时，会发现每一个功能都可以用多种编码方式来实现。但是究竟哪一种方式才是最佳选择呢？在开发 ios 应用程序的过程中，通常使用的编码方式称为“模型-视图-控制器”模式，这种模式简称为 MVC

MVC 是一种设计模式，它能够强制性地使应用程序的输入、处理和输出分开。使用 MVC 的应用程序具有3个核心部件，分别是视图、模型和控制器。

1.视图
视图是用户看到并与之交互的界面.
MVC 的好处是它能为应用程序处理很多不同的视图。视图只是一种输出数据并允许用户操纵的方式。

2.模型
模型表示企业数据和业务规则。在MVC的3个部件中，模型拥有最多的任务。例如，它可能用 EJB 和ColdFusion Components 这样的构件对象来处理数据库.模型返回的数据是中立的。也就是说，模型与数据格式无关，一个模型能为多个视图提供数据.应用于模型的代码只需写一次就可以被多个视图重用。

3.控制器
控制器用于接收用户的输入并调用模型和视图以处理用户的请求。当单击 web 页面中的超链接和发送HTML表单时，控制器本身不输出任何结果，不进行任何处理，它只接受请求并決定调
用哪个模型构件去处理请求，然后确定用哪个视图来显示模型返回的数据。

现在我们总结 MVC 的处理过程。首先控制器接受用户的请求，并决定应该调用哪个模型来进行处理，然后模型用业务逻辑来处理用户的请求并返回数据，最后控制器用相应的视图格式化模型返回的数据，并通过表示层呈现给用户。

##Xcode中的 MVC
在用 Xcode 编程并在 IB 中添加用户界面(UI）元素后，Cocoa Touch 是利用 MVC 模式进行设计的。

xcode 中的视图
要让视图中的对象能够与应用程序实现逻辑交互，必须定义相应的连接。连接的东西有两种
一输出口和操作。
输出口定义了代码和视图之间的一条路径，用于读写特定类型的信息，例如，对应开关的输出口让我们能够查看描述开关是开还是关的信息；而操作定义了应用程序中的一个方法，通过视图中的事件触发。要将输出口和操作连接到代码，必须在实现视图逻辑的代码（即控制器）中定义输出口和操作。

控制器在 xcode 中称为视图控制器，负责处理与视图的交互工作，并在输出口和操作之间建立一个人为连接。为此需要在项目代码中使用两种特殊的编译指令
IBAction  IBOutlet

IBAction  IBOutlet是IB能够识别的标记，我们在视图控制器的接口文件中添加这些编译指令。
视图控制器可包含应用程序逻辑，但这并不意味着所有代码都应包含在视图控制器中。

虽然在本书中大部分代码放在视图控制器中，但当你创建应用程序时，可在合适的时候定义额外的类，以抽象应用程序逻辑。

##数据模型
Core Data 抽象了应用程序和底层数据存储之问的交互。它还包含一个 Xcode 建模工具，该工具像 IB 那样帮助我们设计应用程序，但不是让我们以可视化的方式创建界面，而是让我们以可视化方式建立数据结构。
Core Data 是 Cocoa 中处理数据、鄉定数据的关键特性

托管对象模型：描述应用程序的数据模型，这个模型包含实体 （entity）、属性 （property）等。
托管对象上下文：参与对数据对象进行各种操作的全过程，并监控数据对象的变化，以提供对撤销/重做的支持并更新绑定到数据的 UI。
持久化存储协调器：相当于数据文件管理器，负责底层对数据文件的读取与写入，一般我们无须与与它打交道。
托管对象 (Managed Object，Mo)：与托管对象上下文相关联。
数组控制器、对象控制器、树控制器：一般将托管对象上下文绑定到这些控制器，用于在nib中以可视化的方式操作数据。

上述模块的运作流程如下：
1应用程序创建或读取模型文件（后缀为xcdatamodelId），生成NSManagedObjectModel对象。
Document应用程序一般通过 NSDocument 或其子类（NSPersistentDocument)从模型文件（后缀为 xcdatamodelId）读取
2.生成 NSManagedObjectContext 和 NSPersistentStoreCoordinator 对象，前者对用户透明地调用，后者对数据文件进行读写。
3.NSPersistentStoreCoordinator 从数据文件 (XML、 SQLite、二进制文件等）中读取数据，生成托管对象，或保存托管对象，写入数据文件
4.NSManagedObjectContext 对数据进行各种操作。它持有托管对象，我们通过它来监控托管对象。监控数据对象有两个作用一
一支持撤销/重做以及数据绑定。
5.数组控制器、对象控制器、树控制器等控制器一般与 NSManagedObjectContext 关联，因此通过它们在nib 中可视化地操作数据对象。

#文本框和文本视图
文本框（UITextField）
clearButtonMode：设置一个清除按钮。通过设置 clearButtonMode 可以指定是否以及何时显示清除按钮
UITextField ViewModeAlways：若文本框非空，无论是否获得焦点，都显示清除按钮。
UITextFieldViewModeNever： 不显示清除按钮。
UITextFieldViewModeWhileEditing：若文本框非空，且在编辑状态（及获得焦点 ），显示清除按钮。
UITextFieldViewModeUnlessEditing：若文本框非空，且不在编译状态（焦点不在输入框上），显示清除按钮。

Auto-enable Return Key:如果选择此项，则只有至少在文本框输入一个字符后，键盘的返回键才有效

#按钮
按钮在i0S中是一个视图元素，用于响应用户在界面中触发的事件。按钮通常用 Touch Up Inside 事件来体现，能够抓取用户用手指按下按钮并释放该按钮发生的事件。当检测到事件后，使用按钮触发相应视图控件中的操作 (IBAction)。

#滑块控件、步进控件和图像视图控件
控件是对数据和方法的封装。控件可以有自己的属性和方法。属性是控件数据的简单访问者。方法则是控件的一些简单而可见的功能。


UImageView 的常用属性：animationRepeatCount：动画循环次数。0意味着无限长（默认值为 0

##开关控件和分段控件
复选框和单选按钮虽然不包含在iOS UI 库中，但可以通过 UIButton 类并使
用按钮状态和自定义按钮图像来创建它们。苹果公司让我们能够自由地进行定制，
但不建议在设备屏幕上显示出乎用户意料的控件。

分段控件 (UISegmentedControl)
分段控件常用于在不同类别的信息之间选择，或在不同的应用程序屏幕(如配置屏幕和结果屏幕）之间切换。
如果在一系列值中选择时不会立刻发生视觉方面的变化，应使用选择器 （Picker）对象.

处理用户与分段控件交互的方法是监控 valueChangod 事件，并通过selectedSegmentIndex 判断当前选择的按钮，返回当前选定按钮的编号（按从左到右的顺序对按钮编号


##UIScrollView可滚动视图控件
indicatorStyle：用于设置滚动条的样式，YES 表示显示滚动条，NO 表示隐藏滚动条。
contentlnset：用于在contentSize 周围添加额外的滚动区域，这样可以避免 UISCrollView 中的内容被遮挡。

UIPageControll 翻页控件
翻页控件是一种用来取代导航栏的可见指示器，可方便直接翻页。其典型的应用便是iphone 的主屏幕，当图标过多时会自动增加页面，
在屏幕底部会看到原点，用来指示当前页面，并且会随着翻页自动更新。

## UIView 详解

在i0S里看到的和触模到的都是用 UIView 实现的，
UIView 是在 MVC 中非常重要的一层，是ios下所有界面的基础。
UIView在屏幕上定义了一个矩形区域和管理区域内容的接口。
在运行时，一个视图对象不仅控制该区域的渲染，还控制内容的交互。所以，UIView不仅可以实现画图和动画，还可以管理内容的布局、控制时间。正是因为UIView具有这些功能，它才能发挥MVC中视图层的作用。视图和窗口展示了应用的用户界面，同时负责界面的交互。

官方API为 UIView 定义了各种函数接口。
首先，看视图基本的功能画图和动画，UView所有的绘图和动画的接口都可以用 CALayer 和 CAAnimation 实现
把 CoreAnimation 的功能封装到了 UIView 中。每一个 UIView 都会包含一个 CALayer并且
CALayer 里面可以加入各种动画。
其次，UIView 管理布局的思想其实和 CALayer 是非常接近的。
最后，控制事件的功能是因为 UIView 继承自 UIResponder

CALayer 就是图层，图层的功能是渲染图片和播放动画等。每当创建一个UIView 的时候，系统会自动创建一个 CALayer， 但是你不能改变这个CALayer对象，只能修改某些属性。通过修改CALayer，不仅可以修饰 UIView 的外观，还可以给 UIView 添加各种动画。CALayer 属于CoreAnimation 框架中的类，通过 Core Animation Programming Guide 就可以了解 CALayer中的很多特点。

一个视图对象不仅定义了一个屏幕上的一个矩形区域，还负责处理该区城的绘制和触屏事件。
一个视图不仅可以作为其他视图的父视图，还决定着这些子视图的位置和大小。
UIView类做了大量的工作去管理这些内部视图的关系。
视图与Core Animation层共同负责视图内容的解释和动画过渡。
每个 UIKit 框架里的视图都被一个层对象支持，这通常是一个 CALayer类的实例，它
管理后台的视图存储并处理与视图相关的动画。当需要对视图的解释和动画行为有更多的控制权时，可以使用层。



#视图控制器
UIViewController 的主要功能是控制画面的切换。其中的view属性（UIView类型），管理整个画面的外观。

按住control进行拖拽


#弹出框 分割视图控制器

首先在项目的故事板中新增一个场景，再创建并指定提供支持的视图控制器类。这个类将为弹出框提供内容，因此称为弹出框的 “内容视图控制器”。在初始故事板场景中，创建一个用于触发弹出框的 UI 元素。
，不是在该 UI 元素和要在弹出框中显示的场景之间添加模态切换，而是创建弹出切换。

#设计可旋转和可调整大小的界面

每个UI元素都由屏幕上的一个矩形区域定义，这个矩形区域就是UI元素的 frame 属性。

#多屏任务
如果不使用Slider Over和Split View，需将UIRequiresFullScreen关键字添加到Xcode项目的info.plist文件中，并设置Boolean值为YES

不使用slider over和split view ，表示应用不能出现在slider over区域中，尽管应用运行在多任务环境中

#Core Location框架
Core Location是ios SDK中一个提供设备位置的框架，通过这个框架可以实现定位处理
根据设备的当前位置，可以选择如下3中定位方法：
1 GPS 需要对准天空，在室内无法使用
2 使用手机基站 与基站联系
3 wifi 通过检查服务提供商的数据确定位置，精确度最低

##i0S 应用程序和数据存储

在iOS中对数据实现持久性存储一般有5种方式，分別是文件写入、对象归档、sQLite 数据库、CoreData、NSUserDefaults

iPhone/iPad 设备上包含闪存（flash memory），它的功能和一个硬盘功能等价。当设备断电后数据还能保存下来。
应用程序可以将文件保存到闪存上，并能从闪存中读取它们。应用程序不能访问整个闪存。闪存上的一部分专门用来存储用户的应用程序，这就是用户应用程序的沙箱（sandbox）。每个应用程序只能看到自己的沙箱，这就防止对其他应用程序的文件进行读取活动。
你的应用程序也能看见系统拥有的一些高级别目录，但不能对它们进行写操作。

##直接访问文件系统

直接访问文件系统是指打开文件并读写其内容。这种方法可用于存储任何数据，例如，从Internet 下载的文件、应用程序创建的文件等，但并非能存储到任何地方。在开发 ios SDK时，苹果公司增加了各种限制，旨在防止用户设备受恶意应用程序的伤害。这些限制统称为应用程序沙箱。使用iOS SDK创建的任何应用程序都被限制在沙箱内——无法离开沙箱，也无法消除沙箱的限制。其中一些限制指定了应用程序数据将如何存储以及应用程序能够访问哪些数据。给每个应用程序都指定了一个位于设备文件系统中的目录，应用程序只能读写该目录中的文件。
这意味着一些应用程序最多只能删除自己的数据，而不能删除其他应用程序的数据。

应用程序数据的存储位置

在应用程序的目录中，有4个位置 目录Library/Preferences、 Library/Caches、 Documents 和tmp是专门为存储应用程序数据提供的

在 iPhone模拟器中运行应用程序时，该应用程序的目录位于 Mac 目录/Users/< your user>/Library/Applications Supports/iPhone Simulator/<Device OS Version>/Applications.
该目录可包含任意数量的应用程序的目录，其中每个目录都根据 Xcode 的唯一应用程序 ID（一系列字符和短画线）命名。
要找到当前在 iOS 模拟器中运行的应用程序的目录，最简单的方法是查找最近修改的应用程序目录。如果使用的是 Lion，目录Library默认被隐藏。要访问它，可按住Option键，并单击Finder的Go菜单

通常不直接读写 Library/Preferences 目录，而是使用 NUSuperDefault API。然而，通常直接操纵 Library/Caches、 Documents 和tmp 目录中的文件，它们之间的差别在于其中存储的文件的生命周期。

Library/ Caches 缓存用户从网络获取的数据或通过大量计算得到的数据。该目录中的数据将在应用程序关闭时得以保留，将数据缓存到该目录是
一种改善应用程序性能的重要方法。对于不需要在应用程序关闭后得以保留的数据，如果不把它们存储在设备有限的易失性内存中，可以将其存储到tmp目录中。tmp 目录是 Library/Caches 的临时版本，可将其视为应用程序的便笺本。

##获取文件路径

i0S 设备中的每个文件都有路径，这指的是文件在文件系统中的准确位置。要让应用程序能够读写其沙箱中的文件，需要指定该文件的完整路径。Core Foundation 提供了一个名为 NSSearchPthForDirectoriesInDomains 的C 函数，它返回指向应用程序的目录 Documents 或 Library/Caches 的路径。

该函数可返回多个目录，因此该函数调用的结果为一个 NSArray 对象。当使用该函数来获取指向目录 Doouments 或 Library/Caches 的路径时，它返回的数组将只包含一个 NSString： 要从数组中提取该NSString，可以使用NSArray的objectAtIndex方法，并将索引指定为0

NSString 提供了一个名为 stringByAppendingPathComponent 的方法，可用于合并两个路径段。
通过把调用 NSSearchPathForDirectorieslnDomains 的结果与特定文件名合并起来，获取一条完整的路径，它指向应用程序的 Documents 或 Library/Caches 目录中相应的文件。

Core Data 框架使用 SQLite 作为一种存储格式。你可以把应用程序数据放在手机的核心数捃库上。
然后，你可以使用 NSFetchedResultsController 来访问核心数据库，并在表视图上显示，


Core Data 是一个Coooa框架，用于为管理对象图提供基础实现，以及为多种文件格式的持久化提供支持。
管理对象图包含的工作有撤销（undo）和重做（redo）、有效性检查以及保证对象关系的完整性等。
对象的持久化意味着 Core Data 可以将模型对象保存到持久化存储中，并在需要的时候将它们取出。
Core Data 应用程序的持久化存储（也就是对象数据的最终归档形式）的范围可以从XML文件到SQL数据库。
Core Data适合用在关系数据库的前端应用程序中，所有的Cocoa应用程序都可以利用它的能力。

通过 Core Data 管理应用程序的数据模型，你可以大幅度减少编写的代码数量。Core Data还具有下述特征。
将对象数据存储在 SQLite 数据库中以获得性能优化。
提供 NSFetchedResultsController 类，用于管理表视图的数据，即将 Core Data 的持久化存储显示在表视图中，并对这些数据进行增、删、改。
管理 undo/redo 操作。
检查托管对象的属性值是否正确。

Core Data 中的常用内置方法如下：
fetchedResultsController: objectAtIndexPath：返回指定位置的数据
fetchedResultsController: sections:获取section 数据，返回 NSFetchedResultsSectionlnfo数据。

NSFetchedResultsSectionlnfo是一个协议，定义了下述方法。
numberOfSectionsInTableView： 返回表视图上的 section 数目
tableView:numberOfRowsInSection：返回一个section 的行数。
tableView:cellForRowAtIndexPath：返回cell 信息。
NSEntityDescription类：用于往核心数据库上存放数据。


轻按 (UITapGestureRecognizer)：用一个或多个手指在屏幕上轻按。
按住 (UILongPressGestureRecognizer)：用一个或多个手指在屏幕上按住。
长时间按住 (UILongPressGestureRecognizer)：用一个或多个手指在屏幕上按住到指定时间
张合 (UIPinchGestureRecognizer)：张合手指以缩放对象。
旋转 (UIRotationGestureRecognizer)：沿圆形滑动两个手指。
轻扫 (UISwipeGestureRecognizer)：用一个或多个手指沿特定方向轻扫。
平移(UIPanGestureRecognizer)：触摸并拖曳
上述类都能准确地检测到某一个动作。在创建了上达的对象之后，使用 addGestureRecognizer 方法把它传递给视图。
当用户在这个视图上进行相应操作时，上述对象中的某一个方法就被调用。

触摸就是用户把手指放到屏幕上。系统和硬件一起工作，知道手指什么时候触碰屏幕以及在屏幕中的触碰位置。UIView 是 UIResponder 的子类，触摸发生在 UIView 上。用户看到的和触摸到的是视图(用户也许能看到图层，但图层不是一个UIResponder，它不参与触摸）。触摸是一个 UITouch对象，该对象被放在一个 UIEvent 中，然后系统将 UIEvent 发送到应用程序上。最后，应用程序将UIEvent 传递给一个适当的 UIView。一般不需要关心 UTEvent 和 UITouch。大多数系统视图会处理这些低级别的触摸，并且通知高级别的代码。例如，当 UIButton 发送一个动作消息并报告一个 Touch Up Inside 事件时，它已经汇总了一系列复杂的触摸动作。

单击（tap）：作为最常用的手势(类似于普通鼠标点击）
滑动(fick)：用于实现页面的快速滚动和翻页的功能。
双击(double tap）：可以放大并居中显示图片，或恢复原大小（如果当前已经放大）。
拖动(drag)：用于 实现一些页面的滚动，以及对控件的移动功能。

放大(pinch open）：可以打开订阅源，打开文章。在查看照片的时候，放大手势也可实现放大图片的功能
缩小 (pinch close)：可以实现与放大手势相反的功能：关闭订阅源退出首页，关闭文章退出至索引页。在查看照片的时候，缩小手势也可实现缩小图片的功能。
长按 (touch&hold）：如果针对文字长按，将出现放大镜辅助功能。松开后，则出现编辑菜单。如果针对图片长按，将出现编辑菜单
摇晃 （shake）：摇晃手势，将出现撤销与重做菜单，主要针对用户文本输入。


Force Touch ：
在全新的 Foroe Touch 中，提供了如下的 API类型
pressure sensitivity（压力感应)：例如，通过对压力的感应，在经图过程中使线条交粗或改变画刷的风格
Accelerator（加速器）：通过感应对触控板的压力为用户提供更多的控制。例如，随着压力的增大来快速播放多媒体文件。
Drag and drop（拖曳）：感应用户手势的拖曳过程，根据拖曳距离执行对应的操作。
Force click(单击力度)：应用程序可以感应对按钮、控制区城或在屏幕上进行的单击操作，

#和硬件之间的交互

加速计
加速计以相对于自由落体的方式量度加速度。这意味着如果将 i0S 设备在能够持续自由落体的地方丢下，在下落过程中，其加速计测量到的加速度将为 0g。另外，放在桌面上的设备的加速计
测量出的加速度为 1g，且方向朝上。设备静止时受到的地球引力为 1g，这是加速计用于确定设备朝向的基础。加速计可以测量3条轴 （x轴 y轴 z轴）上的值。

通过感知特定方向的惯性力总量，加速计可以测量出加速度和重力。iphone 内的加速计是一个三轴加速计，这意味者它能够检测到三维空间中的运动或地球引力。因此，加速计不但可以指示握持有电话的方式（如自动旋转功能），如果电话放在桌子上，还可以指示电话的正面朝下还是朝上。加速计可以测量地球引力，因此加速计返回值为 1.0时，表示在特定方向上感知到1g。如果静止握持iphone而没有任何运动，那么地球引力对其施加的力大约为 1g。 如果纵向地握持 iPhone，那么iPhone会检测并报告其y轴上施加的力大约为1g。 如果以一定角度握持 iPhone， 那么 1g 的力会分布到不同的轴上，这取决于握持iPhone 的方式。在以 45°角握持时，1g 的力会均匀地分解到两条轴上。

如果检测到的加速计值远大于 1g，即可以判断这是突然运动。正常使用时，加速计在任意轴上都不会检测到远大于1g的值。如果摇动、坠落或投掷 iPhone，加速计便会在一条或多条轴上检测到很大的力。对于iphone加速计，iPhone长边的左右是x轴（右为正），短边的上下是y轴（上为正），垂直于iphone 屏幕的是Z轴（正面为正）。需要注意的是，加速计对y轴使用了更标准的惯例，即y轴上大于零的值表示向上的力，这与 Quartz2D 的坐标系相反。如果加速计使用 Quartz 2D作为控制机制，那么必须要转换y坐标轴。使用 OpenGL ES 时则不需要转换.

根据设备的放置方式，1g的重力将以不同的方式分布到这3条轴上。如果设备垂直放置，且其一边、屏幕或背面呈水平状态，则整个 1g 都分布在一条轴上。如果设备倾斜，1g将分行到多条轴上。

加速计通常用作游戏控制器，在游戏中使用加速计控制对象的移动。在简单情况下，可能只需获取一个轴的值，乘上某个数（灵敏度)，然后添加到所控制对象的坐标系中。在复杂的游戏中，因为所建立的物理模型更加真实，所以必须根据加速计返回的值调整所控制对象的速度。

陀螺仪
很多初学者误以为，使用加速计提供的数据好像能够准确地猜测到用户在做什么，其实并非如此。加速计可以测量重力在设备上的分布情況，假设设备正面朝上放在桌子上，将可以使用加速计检测出这种情形，但如果在玩游戏时水平旋转设备，加速计测量到的值不会发生任何变化。
当设备通过一边直立着并旋转时，情况也如此。仅当设备的朝向相对于重力的方向发生变化时，加速计才能检测到；而无论设备处于什么朝向，只要它在旋转，陀螺仪就能检测到。陀螺仪是一个利用高速回转体的动量矩敏感壳体相对于惯性空间、绕正交于自转轴的一条或两条轴的角运动检测装置。另外，利用其他原理制成的具有同样功能的角运动检测装置也称陀螺仪。
当我们查询设备的陀螺仪时，它将报告设备绕X轴 y轴和z轴的旋转速度，单位为弧度/秒。2pai孤度相当于 360°，因此陀螺仪返回的读数2表示设备绕相应的轴每秒转 360°

##访问朝向和运动数据
要访问朝向和运动信息，可使用两种不同的方法。其一，要检测朝向变化并做出反应，可以请求 ios 设备在朝向发生变化时向编写的代码发送通知，然后将收到的消息与表示各种设备朝向的常
量（包括正面朝上和正面朝下）进行比较，从而判断出用户做了什么。
其二，可以利用框架 Core Motion 定期地直接访问加速计和陀螺仪数据。

1.通过 UIDevice 请求朝向通知
单例 UIDevice 表示当前设备，它包含方法 beginGeneratingDeviceOrientationNotifications,该方法命令 i0S 将朝向通知发送到通知中心 (NSNotificationCenter)。启动通知后，就可以注册一个NSNotificationCenter实例，以便设备的朝向发生变化时自动调用指定的方法。
除获悉发生了朝向变化事件之外，你还需要获悉当前朝向，为此可使用 UIDevice 的属性orientation。该属性的类型为 UIDeviceOrientation，其可能取值为下面6个预定义值。
UIDeviceOrientationFaceUp：设备正面朝上。
UIDeviceOrientationFaceDown：设备正面朝下。
UIDeviceOrientationPortrait： 设备处于 “正常”朝向，主屏幕按钮位于底部。
UIDeviceOrientationPortraitUpsideDown：设备处于纵向状态，主屏幕按钮位于顶部。
UIDeviceOrientationLandscapeLeft：设备侧立着，左边朝下。
UIDeviceOrientationLandscapeRight：设备侧立着，右边朝下。
通过将属性 orientation 与上述每个值进行比较，你可以判断出朝向并做出相应的反应。

2.使用 Core Motion 读取加速计和陀螺仪数据
当直接使用加速计和陀螺仪时，方法稍有不同。首先，需要将框架 Core Motion 添加到项目中。在代码中需要创建 Core Motion 运动管理器的实例，应该将运动管理器视为单例————由其一个实例向整个应用程序提供加速计和陀螺仪运动服务。单例是在应用程序的整个生命周期内只能实例化一次的类。向应用程序提供的 ios设备硬件服务通常是以单例方式提供的。由于设备中只有一个加速计和一个陀螺仪，因此以单例方式提供它们合乎逻辑。在应用程序中包含多个 CMMotionManager对象不会带来任何额外的好处，而只会让内存和生命周期的管理更复杂，而使用单例可避免这两种情况发生。

不同于朝向通知，Core Motion 运动管理器能够指定从加速计和陀螺仪那里接收更新的频率(单位为秒），还能够直接指定一个处理程序块（handler block)，每当更新就绪时都将执行该处理程序块。

我们需要判断以什么样的频率接收运动更新对应用程序有好处。为此，可尝试不同的更新频率，直到获得最佳的频率。如果更新频率超过了最佳频率，可能带来一些负面影响：应用程序将使用更多的系统资源，这将影响应用程序其他部分的性能。当然，还有电池的寿命。由于可能需要非常频繁地接收更新以便应用程序能够平滑地响应，因此应花时间优化与CMMotionManager相关的代码。

##使用扩展
通过系统提供的拓展接入点（extension point）来为系统特定的服务提供某些附加功能。

通过 Sprite Kit 制作2D 游戏的主要优点如下：
1.内置于 ios，不需要再额外下载类库，也不会产生外部依赖。它是由苹果公司官方编写的，可以确信它会被良好支持和持续更新
2.为纹理贴图集和粒子提供了内置的工具。
3.可以做一些用其他框架很难甚至不可能做到的事情，比如把视频当作 Sprite 对象来使用或者实现很炫的图片效果和遮罩。

主流的二维游戏开发框架有 Sprite Kit、 Cocos2D、Cocos2D-X 和Unity：

苹果公司提供了 sirikit 框架，在用户使用 siri 的时候会生成 INExtension对象来告知我们的应用，通过实现特定的方法来让 Siri 获取应用想要展示给用户的内容。

在用户使用 siri 的时候会生成 INExtension对象来告知我们的应用，通过实现特定的方法来让 Siri 获取应用想要展示给用户的内容。siri 通过语言处理系统对用户发出的对话请求进行解析，然后生成一个用来描述对话内容的 Intents 事件，再通过 Sirikit 框架分发给集成框架的应用，以此来获取应用的内容，比如完成类似于通过文字匹配、查找应用聊天记录、聊天对象的功能


在ios应用程序中，Siri 将作为扩展程序来使用。SiriKit 为开发者提供了一全套从语音识别到代码处理，最后向用户展示结果的流程。苹果公司添加了一套全新的框架 Intents.framework 来表示 Sifi 获取并解析的结果。在开发的应用程序中需要提供一些关键字以表明可以接受相关输入，而 Siri 扩展只需要监听系统识别的用户意图（intent)，做出合适的响应、修改以及实际操作，最后通过IntentsUI.framework 提供反馈。整个开发过程非常清晰明了，但是这也意味着开发者所能拥有的自由度有限。

Siri 和应用程序通过 Intents extension 进行交互，其中类型为 INExtension 的对象扮演着 Intentsextension 中直接协同 Siri 对象共同响应用户请求的关键角色。当实现了 Intents extension 并产生了一个 Siri 请求事件时，
一个典型的Intent事件的处理过程有如下了个步骤。

解析阶段：在Siri获取用户的语音输入之后，生成一个INIntent对象，将语音中的关键信息提取出来并且填充对应的属性。这个对象在稍后会传递给我们设置好的 INExtension 子类对象并进行处理，根据子类遵循的不同服务协议来选择不同的解决方案。

确认阶段：在上一个阶段通过处理程序返回了处理 Intent 的对象，此阶段会依次调用以Confirm 开头的实例方法来判断 Siri 填充的信息是否完成。匹配的判断结果包括 Exactly one match、 Two or more matches 以及 No match 3种情况。这个过程中可以让 Siri 向用户征求更具体的参数信息。

处理阶段：在 Confirm 方法执行完成之后，siri 进行最后的处理，生成答复对象，并且向此Intent 对象确认处理结果，然后显示结果给用户看。


Apple Watch 主要负责保存用户界面元素文件（故事板文件和静态的图片文件）并处理用户的输入行为。相关代码不会真正在 Apple Watch 中运行，也就是说，Apple Watch仅是一个“视图”容器。
在iPhone 中包含的所有逻辑代码，用于响应用户在 Apple Watch 上产生的行为，例如应用启动、单击按钮和滑动滑块等。也就是说，iPhone 包含了控制器和模型代码。

上述 Apple Watch 和iPhone 的这种交互操作是在幕后自动完成的，开发者要做的工作只是在故事板中设置好UI的Outlet，其他的步骤由 WatchKit SDK 在幕后通过蓝牙技术自动进行交互即可。即使 iPhone 和 Apple Watch 是两个独立的设备，也只需要关注本地的代码以及 Outlet 的连接情况。

在Watch应用的架构模式中，要针对 Apple Watch 进行开发，首先需要建立一个传统的i0S应用，然后在其中添加Watch应用的 target 对象。添加后会在项目中多出如下两个 target 对象。添加后会在项目中多出如下两个 target对象：
WatchKit Extension
Watch 应用

原则上来说，我们应该将与界面相关的内容放在Watch应用的target中，而将所有代码逻辑等放到WatchKit Extension里

Watchkit 布局:
只需要将按钮和标签之类的界面元素添加到 Group 中,Group 将自动为添加的界面元素在内部进行布局.
在Watch 应用中，你可以将一个 Group 嵌入另一个Group 中，用于实现较复杂的界面布局，并且可以在 Group 中设置背景色、边距和圆角半径等属性。



